## 学習 / 作業 時間

3 時間 45 分

## 今日取り組んだこと

- state や useRef の不明点を調べた
- useEffect を学習

## 学んだこと・気づいたこと

- レンダーコードとは、コンポーネントのトップレベルにあるものである。props や state を受け取り、変換し、画面に表示したい JSX を返す場所のこと。
- イベントハンドラは、コンポーネント内の関数であり、何かを実行するためのものである。
  イベントハンドラには、ユーザーの特定のアクションによって、プログラムの状態を変更する副作用が含まれている。

上記 2 つだけでは、実行できない機能もある。外部サーバーに常に接続したい状況の場合など、2 つだけでは機能しない。サーバー接続は、純粋な計算ではない (副作用がある) ため、レンダー中に行うことが出来ない。

- エフェクトは、特定のイベントではなく、レンダー自体によって引き起こされる副作用を指定するためのものである。
- コンポーネントがレンダーされ、画面を更新後に、`useEffect` が実行される。
- レンダー中に DOM 操作等の副作用を含んではならない。レンダーは JSX の純粋な計算であるべきであるため。なので、副作用を `useEffect` でラップして、レンダーの計算処理の外に出すと良い。

## 不明点・課題

- [x] 「state を更新すると、レンダーがチューイングする」とはどういう意味か？

  state を更新すると、そのコンポーネントの「再レンダー」が予約される。

  1. React に「state が変わったよ」と伝わる
  2. React が「じゃあこのコンポーネントをもう一回実行しよう」と判断
  3. **関数コンポーネントがもう一度実行される**
  4. 新しい JSX が作られる
  5. 画面が更新される

  つまり：

  > ✅ state 更新 = 再レンダーのきっかけを作る行為

- [x] 「レンダーをトリガする」とはどういう意味か？

  これはまさに今の話で、

  > React に「もう一回このコンポーネントを実行して」と合図を出すこと

  トリガする代表例：

  - ✅ `setState`
  - ✅ `setCount`
  - ✅ 親コンポーネントの再レンダー
  - ✅ context の更新

  逆に：

  - ❌ 普通の変数の変更
  - ❌ useRef の current 変更

  これらは **レンダーをトリガしない**。

- [x] 再帰的とは？

  React の文脈での「再帰的」はこういう意味：

  > 「レンダーの結果が、次のレンダーの原因になる構造」

  例えば：

  ```jsx
  setCount(count + 1);
  ```

  1. → 再レンダー
  2. → JSX 再生成
  3. → イベント再登録
  4. → またクリックで setCount
  5. → また再レンダー…

  この「同じ流れが何度も繰り返される構造」を「再帰的」「ループ構造的」と表現することがある。

  ※数学のガチ再帰とは少しニュアンスが違う

  → **「何度も自分を呼び直す構造」くらいの理解で OK**

- [x] スナップショットとは？

  これは「そのレンダー時点の UI の設計図」のこと。

  React はレンダーのたびに：

  - state
  - props
  - ローカル変数

  これらを元に：

  ```jsx
  return <button>{count}</button>;
  ```

  という「その瞬間の UI 構造」を作る。

  これが **UI のスナップショット**。

  重要なのは：

  > ✅ スナップショットは「写真」のようにその瞬間で完全に固定されたもの

  だから：

  ```jsx
  setCount(count + 1);
  console.log(count);
  ```

  で **古い count が出る**のは、

  > その行が「古いスナップショットの中」にいるから

- [x] スナップショットと仮想 DOM は別物？

  ✅ **別物だけど、かなり近い関係**

  | 用語             | 正体                                                            |
  | ---------------- | --------------------------------------------------------------- |
  | スナップショット | **関数が返した JSX の結果（論理的な UI）**                      |
  | 仮想 DOM         | **そのスナップショットを React が内部でオブジェクト化したもの** |

  流れとしては：

  ```
  state / props
     ↓
  関数コンポーネント実行
     ↓
  JSX（スナップショット）
     ↓
  仮想DOM（オブジェクト構造）
     ↓
  前回と比較（diff）
     ↓
  実DOM更新
  ```

  ✅ スナップショット ＝ 設計図

  ✅ 仮想 DOM ＝ その設計図を React が計算用に変換したデータ

- [x] useRef を使用する場合、「再レンダーされない」とされているが、仮想 DOM との差分の算出は行なわれるのか？

  ✅ 結論：

  > 行われません。なぜなら「レンダー自体が起きない」から

  useRef の `.current` を変えても：

  - 関数コンポーネントは再実行されない
  - 新しい JSX は作られない
  - 仮想 DOM も再生成されない
  - 差分比較も行われない

  つまり：

  ```jsx
  ref.current = 10;
  ```

  これは：

  > ✅ React の描画システムの外で、ただの変数を書き換えているだけ

- [x] 画面描画までのプロセスで、state となにか違うことはあるか？

  ✅ 決定的に違う

  state の流れ：

  ```
  setState
   → 再レンダー
   → 新しい JSX
   → 仮想DOM作成
   → 差分比較
   → 実DOM更新
   → 画面変わる
  ```

  useRef の流れ：

  ```
  ref.current 書き換え
   → 何も起きない
   → 再レンダーなし
   → JSX作り直されない
   → 仮想DOMも更新されない
   → 画面も変わらない
  ```

  ✅ **useRef は「描画パイプラインに一切乗らない」**

- [x] 再レンダーされないのであれば、画面への反映は行なわれない？

  ✅ **その通り。基本的に反映されない。**

  ```jsx
  const ref = useRef(0);

  ref.current = 100;
  ```

  これをやっても：

  - JSX が再計算されない
  - `{ref.current}` を表示していても画面は変わらない

  ✅ ただし例外が 1 つだけある：

  🔹 DOM を直接操作した場合

  ```jsx
  inputRef.current.value = "abc";
  ```

  これは：

  - React を経由せず
  - **ブラウザの DOM を直接書き換えている**

  ので、**画面は変わる**。

  でもこれは：

  > ✅ React 的には「知らないところで勝手に変わっているだけ」

- [ ] 副作用とは、イベントハンドラ内に限定されるものなのか？もっと広い意味なのか？

## メモ

## 次やること

useEffect の学習を進める。
